# Практична робота №2

В даній практичній роботі треба виконати 5 загальних завдань і одне по варіанту. Нижче описаний процес виконання кожного з них

## Завдання 1
**Напишіть програму для визначення моменту, коли time_t закінчиться.Дослідіть, які зміни відбуваються в залежності від 32- та 64-бітної архітектури. Дослідіть сегменти виконуваного файлу.**
### Попередні вимоги
Для успішної компіляції 32-бітного коду на 64-бітній операційній системі необхідно встановити пакет підтримки мультіліб:
```
sudo apt update
```
```
sudo apt install build-essential gcc-multilib
```
### Реалізація програми
Вхідний код програми знаходиться в файлі time_test.c. Як запустити програму буде описано трошки нижче.

**Програма виконує наступні дії**:

1. Визначає розмір time_t у байтах.

2. Обчислює максимально можливе значення для цього типу.

3.  Конвертує отримане число у дату формату UTC.

### Проблеми, що виникли під час виконання цього завдання

Під час розробки 64-бітної версії була виявлена критична помилка компіляції: `integer overflow in expression`.

При спробі обчислити максимальне значення для 64-бітного типу, використовувався наступний вираз:
`1 << 63`

У мові C літерал 1 за замовчуванням є знаковим цілим ака _signed int_. Зсув одиниці на 63-ю позицію (у знаковий біт) призводить до **невизначеної поведінки** або **переповнення**, оскільки число стає від'ємним.
#### Рішення проблеми
Код було модифіковано шляхом явного приведення одиниці до беззнакового типу (unsigned long long) перед виконанням побітового зсуву.

Фрагмент виправленого коду: 
```c
// Першочерговий невірний код: const long long max_time_val = ((long long)1 << (sizeof(time_t) * 8 - 1)) - 1;
const long long max_time_val = (long long)( ((unsigned long long)1 << (sizeof(time_t) * 8 - 1)) - 1 );
```
### Компіляція та запуск
Для аналізу і власне відповіді на питання з завдання потрібно скомпілювати дві версії програми.

#### 1. 32-бітна версія
-----------------------------------------
Для емуляції 32-бітного середовища використовується прапорець `-m32`

```
gcc -m32 time_test.c -o time32
```
Після успішної компіляції програми варто її запустити ось цією командою:
```
./time32
```
**Після запуску 32- бітної програми ви побачите ось такий результат**:

<img width="770" height="152" alt="Знімок екрана 2026-02-13 155639" src="https://github.com/user-attachments/assets/e575e138-e48b-40cd-82b7-d44d962c0b88" />

#### 2. 64- бітна версія
--------------------------
В цьому випадку скористаємося стандартною компіляцією до Убунту, бо нині всі комп'ютери мають 64-бітне середовище.
```

gcc -Wall time_test.c -o time64
```
Після успішної компіляції програми варто її запустити ось цією командою:
```
./time64
```
**Після запуску 64-бітної програми ви побачите ось такий результат**:

<img width="741" height="151" alt="Знімок екрана 2026-02-13 160557" src="https://github.com/user-attachments/assets/6175c930-4d64-41b4-985d-343dd327e068" />


Вже зараз можна побачити різницю в результатах, проаналізуємо їх за допомогою таблиці.
#### Таблиця виконання

| Характеристика | 32-бітна архітектура | 64-бітна архітектура (time64) |
| :--- | :---: | :---: |
| **Розмір time_t** | 4 байти (32 біти) | 8 байт (64 біти) |
| **Макс. Timestamp** | 2,147,483,647 | 9,223,372,036,854,775,807 |
| **Критична дата** | 2038-01-19 03:14:07 UTC | ~292 мільярди років у майбутньому |

### Аналіз сегментів(використання команди size)
`size` - це стандартна утиліта в Лінукс, яка показує структуру пам'яті програми. Вона не просто каже скільки файл займає місця на диску, а і розбиває її на логічні сегменти. Саме це нам і потрібно.

**Щоб проаналізувати нашу програму використаймо цю команду:**
```
size time32 time64
```
<img width="794" height="159" alt="Знімок екрана 2026-02-13 160037" src="https://github.com/user-attachments/assets/51b234db-ffd4-4d02-9a4b-70dad74c5ac3" />

На екрані побачимо ось такий результат

 #### Виглядає звісно гарно але _що це все означає_?

* **text(код)**

Код програми, що виконує процесор. Ця область доступна лише для читання і в 64-бітній версії відрізняється тим, що цей сегмент більший. Тому що інструкції та адреси пам'яті 64-бітного процесора займають більше місця.

* **data(дані)**

В цьому сегменті знаходяться глобальні змінні, яким ми дали початкове значення.

* **bss(block started by symbol)**

Тут знаходяться глобальні змінні без значення, тобто неініціалізовані.Цікавий факт, цей сегмент не займає місце у файлі на диску, але займає місце в оперативній пам'яті під час запуску програми.

* **dec(десятковий)**

Загальний розмір програми в байтах у звичній десятковій системі.

* **hex(шістнадцядковий)**

Те саме число тільки в шістнадцядковій системі числення.

### Висновок

Ми довели різницю архітектур, вона показана на таблиці:
| Файл | Сегмент text | Опис |
| :--- | :---: | :--- |
| **time32** | Менше | Використовує короткі адреси (4 байти). |
| **time64** | Більше | Використовує довгі адреси (8 байт), тому сама програма "товстіша". |

 А також підтверджено, що 32-бітні системи не здатні обробляти час після січня 2038 року. Після цієї дати значення часу стане від'ємним, що призведе до критичних помилок.

---------------------------------------------------------------------------------------
## Завдання 2
#### Розгляньте сегменти у виконуваному файлі.
##### 1. Скомпілюйте програму "hello world", запустіть ls -l для виконуваного файлу, щоб отримати його загальний розмір, і запустіть size, щоб отримати розміри сегментів всередині нього.
##### 2. Додайте оголошення глобального масиву із 1000 int, перекомпілюйте й повторіть вимірювання. Зверніть увагу на відмінності.
#### 3. Тепер додайте початкове значення в оголошення масиву (пам’ятайте, що C не змушує вас вказувати значення для кожного елемента масиву в ініціалізаторі). Це перемістить масив із сегмента BSS у сегмент даних. Повторіть вимірювання. Зверніть увагу на різницю.
##### 4. Тепер додайте оголошення великого масиву в локальну функцію. Оголосіть другий великий локальний масив з ініціалізатором. Повторіть вимірювання. Дані розташовуються всередині функцій, залишаючись у виконуваному файлі? Яка різниця, якщо масив ініціалізований чи ні?
##### 5. Які зміни відбуваються з розмірами файлів і сегментів, якщо ви компілюєте для налагодження? Для максимальної оптимізації?
#### Проаналізуйте результати, щоб переконатися, що:
##### *  сегмент даних зберігається у виконуваному файлі;
##### *  сегмент BSS не зберігається у виконуваному файлі (за винятком примітки щодо його вимог до розміру часу виконання);
##### *  текстовий сегмент більшою мірою піддається перевіркам оптимізації;
##### *  на розмір файлу a.out впливає компіляція для налагодження, але не сегменти.**

### Пункт 1

Створимо мінімальну програму для встановлення базових значень розмірів. Програма для цього завдання знаходиться в файлі test_helo.c. Всі зміни даного файлу можна переглянути в комітах.

**Створіть файл з усім відомою програмою Hello World**:
```c
#include <stdio.h>

int main() {
    printf("Hello World!!!\n");
    return 0;
}
```
_P.S. Для створення цього файлу в віртуальній машині скористайтесь командою_:
```
nano test_helo.c
```

### Для компіляції та вимірювань скористайтеся наступними командами
 ```
gcc -Wall test_helo.c -o hello
```
------------------------------------
```
ls -l hello
```
#### На екрані повинен з'явитись ось такий результат:

<img width="729" height="126" alt="Знімок екрана 2026-02-13 164908" src="https://github.com/user-attachments/assets/ee46e8e2-6f0a-46cd-a246-4340c0ae171d" />

На зображенні можемо побачити що розмір файлу невеликий.




-------------------------------------------
```
size test
```
#### На екрані з'явиться такий результат:

<img width="711" height="142" alt="Знімок екрана 2026-02-13 164921" src="https://github.com/user-attachments/assets/e8702528-bd0d-4ce9-90df-69c0cc5c7164" />

На зображенні бачимо,що data i bss мають мінімальні значення

### Пункт 2

Додамо глобальний масив без початкових значень(неініціалізований)

**Перед int main додайте ось цей рядок:**
```c
int global_arr[1000];
```
### Скомпілюйте тим самим чином, що і в пункті один і виконайте команди вимірювань
------------------------------------
```
ls -l hello
```
#### На екрані повинен з'явитись ось такий результат:

<img width="715" height="128" alt="Знімок екрана 2026-02-13 165510" src="https://github.com/user-attachments/assets/8ef2edf1-0bb0-48e4-96a6-1f127c74f970" />


Бачимо, що файл на диску майже не змінився

-------------------------------------------
```
size test
```
#### На екрані з'явиться такий результат:


<img width="793" height="146" alt="Знімок екрана 2026-02-13 165525" src="https://github.com/user-attachments/assets/8f950467-9aa1-46d3-bc31-518113a4583b" />

 Бачимо, bss виріс приблизно на 4000 байт

#### Чому так?
BSS не зберігає нулі фізично. Він зберігає лише метадані (заголовок), який виділяє 4000 байт пам'яті при запуску і зануляє їх

### Пункт 3
Ініціалізуємо масив, щоб перемістити його з BSS у Data

**Змініть доданий в 2 пункті рядок на:**
```c
int global_arr[1000] = {1};
```
### Скомпілюйте тим самим чином, що і в пункті один і виконайте команди вимірювань
------------------------------------
```
ls -l hello
```
#### На екрані повинен з'явитись ось такий результат:

<img width="707" height="121" alt="Знімок екрана 2026-02-13 165709" src="https://github.com/user-attachments/assets/674c8c9d-1e9e-487c-a9e7-0bea8a7173bf" />

В результаті файл на диску збільшився на 4000 байт.

#### Чому так?
Оскільки значення відмінні від нуля, вони повинні зберігатися у бінарному файлі, щоб програма могла їх зчитати.

-------------------------------------------
```
size test
```
#### На екрані з'явиться такий результат:

<img width="701" height="143" alt="Знімок екрана 2026-02-13 165730" src="https://github.com/user-attachments/assets/8c5d9162-7656-44fc-b21c-b1cf6f6fbfd7" />


В результаті сегмент bss зменшився до мінімуму, а сегмент data виріс на 4000 байт.

### Пункт 4
Стек. Перемістимо масиви всередину функції.

**Замість рядка, що ми написали в 3 пункті, вставте ось цю функцію:**
```c
void func() {
    int local_arr[1000];          
    int local_arr_init[1000] = {1};
}
```
### Скомпілюйте тим самим чином, що і в пункті один і виконайте команди вимірювань

_P.S. Через те що ми компілюємо через `-Wall` і просимо компілятор повідомляти про все, що його не влаштовує він може сваритися. Але нашому дослідженню це не завадить_

------------------------------------
```
ls -l hello
```
#### На екрані повинен з'явитись ось такий результат:

<img width="724" height="124" alt="Знімок екрана 2026-02-13 171206" src="https://github.com/user-attachments/assets/fd612118-f469-4fb2-817d-21c46b2cbda8" />

-------------------------------------------
```
size test
```
#### На екрані з'явиться такий результат:


<img width="707" height="140" alt="Знімок екрана 2026-02-13 171218" src="https://github.com/user-attachments/assets/fdfad11b-37c0-4c79-8842-8933d5b2658b" />

bss i data повертаються до розмірів як в Пункті 1

#### Чому так?
Локальні змінні зберігаються у стеку. Стек створюється динамічно під час виконання програми в оперативній пам'яті. Він не є статичним сегментом у виконуваному файлі

### Пункт 5
Використовуємо код із пункту 3, але додамо використання змінної, щоб оптимізатор не видалив її

**Для виконання цього пункту команда компіляції змінюється і виглядає подібним чином:**
```
gcc -g test_helo.c -o test_debug
```
------------------------------------
```
ls -l hello
```
#### На екрані повинен з'явитись ось такий результат:

<img width="762" height="126" alt="Знімок екрана 2026-02-13 171634" src="https://github.com/user-attachments/assets/e84c46b3-e34b-469e-9224-54787c221733" />


В результаті файл на диску значно більший (зберігає таблиці символів, імена змінних, прив'язку до рядків коду).


-------------------------------------------
```
size test
```
#### На екрані з'явиться такий результат:
<img width="748" height="148" alt="Знімок екрана 2026-02-13 171654" src="https://github.com/user-attachments/assets/55e1fa92-3a0b-456e-ab4d-93e7a9c41c88" />

Cегменти залишились майже без змін. Налагоджувальна інформація не завантажується в пам'ять як частина виконуваних сегментів.

**Для максимальної оптимізації код ще можна скомпілювати ось таким чином:**
```
gcc -o3 test_helo.c -o test_opt
```
------------------------------------
```
ls -l hello
```
#### На екрані повинен з'явитись ось такий результат:

<img width="742" height="127" alt="Знімок екрана 2026-02-13 171848" src="https://github.com/user-attachments/assets/24eadef5-1d5c-4bef-b8e6-19e8f261825a" />


-------------------------------------------
```
size test
```
#### На екрані з'явиться такий результат:
<img width="706" height="140" alt="Знімок екрана 2026-02-13 171905" src="https://github.com/user-attachments/assets/9b816116-e63b-4337-9b60-885478a01292" />

Сегмент text може зменшитися (видалення зайвого) або збільшитися (розгортання циклів). Сегмент data залишиться на місці, бо ми використали масив у printf. Якби ми не використали масив, розумний оптимізатор видалив би його повністю.

### Для аналізу результатів та фінального порівняння представлена таблиця:

| Зміна в коді | сегмент Data | сегмент BSS | Розмір файлу на диску | Де живуть дані? |
| :--- | :---: | :---: | :---: | :--- |
| **Hello World** | ~500 B | ~10 B | Малий | — |
| **Глобальний `int a[1000]`** | Без змін | +4000 B | Без змін | RAM (виділяється при старті) |
| **Глобальний `int a[1000]={1}`** | +4000 B | Без змін | +4000 B | Всередині файлу EXE |
| **Локальні масиви** | Без змін | Без змін | Без змін | Стек  |
| **Debug (-g)** | Без змін | Без змін | Дуже великий | Секції Debug info |

### Висновки
В цьому завданні ми наочно продемонстрували, що спосіб оголошення та ініціалізації змінних визначає їхнє розміщення у пам'яті та вплив на розмір виконуваного файлу. Зокрема, ініціалізовані глобальні дані зберігаються у сегменті data і збільшують фізичний розмір файлу на диску, тоді як неініціалізовані потрапляють у сегмент bss, займаючи місце лише в оперативній пам'яті під час виконання програми. Локальні змінні взагалі не впливають на статичні сегменти, оскільки розміщуються на стеку динамічно, а додавання налагоджувальної інформації суттєво збільшує файл за рахунок метаданих, не змінюючи при цьому розмір завантажуваних у пам'ять частин коду та даних.

------------------------------------------------------------------------------------------
## Завдання 3
#### Скомпілюйте й запустіть тестову програму, щоб визначити приблизне розташування стека у вашій системі:
```c
#include <stdio.h>

int main() {
    int i;
    printf("The stack top is near %p\n", &i);
    return 0;
}
```
#### Знайдіть розташування сегментів даних і тексту, а також купи всередині сегмента даних, оголосіть змінні, які будуть поміщені в ці сегменти, і виведіть їхні адреси.
#### Збільшіть розмір стека, викликавши функцію й оголосивши кілька великих локальних масивів. Яка зараз адреса вершини стека?
_Примітка: стек може розташовуватися за різними адресами на різних архітектурах та різних ОС. Хоча ми говоримо про вершину стека, на більшості процесорів стек зростає вниз, до пам’яті з меншими значеннями адрес._

Завдання було поділено на дві частини для кращих результатів дослідження.

 ### Частина 1. Ідентифікація основних сегментів пам'яті

 Для початку скопіюйте і скопмілюйте код вказаний в завданні вище. Для компіляції використайте ось цю команду:
 ```
gcc -Wall memory.c -o memory
```

Запустіть прогаму командою 
```
./memory
```
Це допоможе визначити приблизне розташування стека у вашій системі. Приблизне розташування стеку у моїй системі ось таке:
<img width="762" height="215" alt="Знімок екрана 2026-02-14 102149" src="https://github.com/user-attachments/assets/10e7a9be-126d-4dea-858e-e74444edf1d3" />

#### Для виводу на екран адреси основних сегментів пам'яті, нам треба відредагувати скопійований код. Фінальна версія потрібного коду знаходиться в файлі `memory.c`

Двалі просто скомпілюйте код і запустіть його командами зазначеними вище.

**На консолі з'явиться ось такий результат:**

<img width="797" height="185" alt="Знімок екрана 2026-02-14 103432" src="https://github.com/user-attachments/assets/408f590c-a0df-4a3b-aa67-db4ab98a4be2" />

Ви можете побачити адреси в шістнадцятковому форматі. Сегменти коду та даних розташовані за найменьшими адресами. Купа знаходиться вище і росте вгору, тоді як стек має  найбільші адреси.

#### Що таке купа і стек?
В цій роботі ми розглядаємо сегменти і якщо text, bss та data були описані і досліджені в минулих завданнях не один раз, купа тут ще не траплялася. Тож що це таке?

* **Купа** - використовується для динамічного виділення пам'яті під час виконання програми за допомогою `malloc`
* **Стек** - зберігає локальні зміні функцій, адреси повернення та аргументи.


### Частина 2. Дослідження напрямку росту стека

В цій частині ми дослідимо, як змінюється адреса вершини стека при виклику нової функції та розміщенні в ній великого масиву даних. В примітці було вказано, що на архітектурах х64 стек росте вниз від більших адрес до меньших.

**Вхідний код для цього завдання знаходиться в файлі `stack.c`**

Скомпілюйте програму та запустіть її командами:
```
gcc -Wall stack.c -o stack
```
_P.S. Компілятор знову буде трошки сваритися, не звертайте на нього уваги, виконанню завдання це не завадить_
```
./stack
```

#### В консолі ви побачите подібний результат:
<img width="713" height="142" alt="Знімок екрана 2026-02-14 104142" src="https://github.com/user-attachments/assets/470f1f9b-fb9e-4576-b9cd-9817eec547c9" />

Програма спочатку виводить адресу локальної змінної у головній функції. Потім відбувається виклик функції `grow_stack`, всередині якої оголошено масив на 10 000 елементів чисельного типу. Виведена адреса локальної зміної всередині `grow_stack` буде суттєво меншою за адресу в головній функції. **Таким чином, це доводить, що виділення місця під великий масив стек _виріс униз_ в бік меньших адрес**.

### Цікава примітка
У сучаних дистрибутивах Лінукс за замовчуванням увімкнено механізм рандомізації розміщення адресного простору. І саме через це, при кожному новому запуску програм адреси сегментів будуть динамічно змінюватися. Це додали для захисту від атак "переповнення буфера". Спробуйте запустити код `memory.c` знову. Чи помітили ви зміну адреси?

**Якщо запустити програму `memory.c` ще раз і порівняти зі скриншотом з частини 1. Можна побачити що адреси дійсно змінились**
<img width="702" height="190" alt="Знімок екрана 2026-02-14 112558" src="https://github.com/user-attachments/assets/32e18274-fe5d-45b9-8204-82cd02642afc" />

------------------------------------------------------------------------------------------
## Завдання 4
**Ваше завдання – дослідити стек процесу або пригадати, як це робиться. Ви можете: Автоматично за допомогою утиліти gstack.Вручну за допомогою налагоджувача GDB.Користувачі Ubuntu можуть зіткнутися з проблемою: на момент написання (Ubuntu 18.04) gstack, схоже, не був доступний (альтернативою може бути pstack).**
**Завдання: Ознайомтеся з виводом gstack і порівняйте його з GDB.**

Для роботи був створений файл `stack_process.c`, який знаходиться в даній папці, із наступним ланцюжком викликів: 
`main()` --> `foo()` --> `bar()` --> `bar_is_now_closed()` --> `pause()`

### Компіляція. Щоб відкладчик міг бачити імена функцій обов'язково компілювати з `-g` як показано нижче:
```
gcc -g stack_process.c -o process
```
За допомогою ось цієї команди, варто запустити програму в **фоновому режимі:**
```
./process &
```
### Результат виконання виглядатиме подібним чином:
<img width="812" height="322" alt="Знімок екрана 2026-02-15 110150" src="https://github.com/user-attachments/assets/521d0e40-29e7-4476-b799-7912df34d938" />
<img width="144" height="27" alt="Знімок екрана 2026-02-15 110944" src="https://github.com/user-attachments/assets/6da6c2d4-b674-4024-9dbf-d0dd935761b7" />

Система повернула ідентифікатор процесу. У мене це 967.

_P.S. Якщо ви не помітили ідентифікатор процесу під час показаних раніше команд можете запустити його за допомогою ось цієї команди_
```
pidof process
```
### Ручний аналіз за допомогою GDB
Якщо до цього відкладчик gdb не був встановлений на віртуальній машині, зробіть це за допомогою команд:
```
sudo apt update
```

```
sudo apt install gdb -y
```
Після встановлення програми, запустіть її командою:
```
sudo gdb --quiet
```
В терміналі ви побачите **(gdb)**. Це запрошення внутрішнього терміналу підключитись до процесу.
Тож для підключення до процесу використайте цю команду:
```
(gdb) attach < ваш PID>
```
**В моєму випадку це виглядало подібним чином**:
<img width="702" height="235" alt="Знімок екрана 2026-02-15 111453" src="https://github.com/user-attachments/assets/4b6ec811-f137-4eba-88a4-a6a9948c884a" />

Наступним кроком буде перегляд стека викликів за допомогою команди:
```
(gdb) bt
```
**Ось такі кадри ви повинні побачити в терміналі:**
<img width="877" height="197" alt="Знімок екрана 2026-02-15 111617" src="https://github.com/user-attachments/assets/39a01172-3bde-40b0-bc93-cccfc810e6b0" />

Далі _не забудьте відключитись і вийти з gdb_
```
(gdb) detach
```

```
(gdb) quit
```

### Ручний аналіз за допомогою pstack\gstack
Утиліта `gstack` зазвичай відсутня в сучасних версіях Убунту, тому використовується її альтернатива - `pstack`.

Але навіть існуючу альтернативу треба спочатку встановити за допомогою команди:
```
sudo apt install pstack -y
```
#### І тут у мене виникла помилка
<img width="844" height="175" alt="Знімок екрана 2026-02-15 111900" src="https://github.com/user-attachments/assets/7a4c0873-00bb-479c-b638-944f377f004d" />

Утиліта видала помилку читання пам'яті. Причиною стала, виявляється відома проблема сумісності старої утиліти з сучасними механізмами безпеки ядра Лінукс в убунту. Навіть команда від імені адміністратора `sudo` не завжди дозволяє `pstack` прочитати пам'ять процесу

**Знайдене альтернативне рішення**

`pstack` ми можемо стимулювати в gdb в неінтерактивному режимі, бо ця утиліта це тільки обгортка навколо gdb.
```
sudo gdb --batch -ex "bt" -p <Ваш PID>
```
Ця команда підключається до процесу, виконує `bt` і миттєво виходить, ідеально замінюючи неробочий `pstack`

<img width="697" height="192" alt="Знімок екрана 2026-02-15 112327" src="https://github.com/user-attachments/assets/8388f4e6-a3f9-4c6e-9c1e-1929c48d2f7f" />

### Порівняння виводу gstack та gdb
Після практичної частини цього завдання прийшов час провести аналіз результатів.

| Характеристика | gdb (`bt`) | gstack / pstack |
| :--- | :--- | :--- |
| **Вміст виводу** | Детальний стек викликів (кадри, функції, адреси). | Ідентичний виводу gdb. Бачимо ті самі кадри від `pause()` до `main()`. |
| **Режим роботи** | **Інтерактивний**. Процес призупиняється, при знаходженні у gdb. | **Неінтерактивний** (миттєвий знімок стану). |
| **Призначення** | Глибоке налагодження (перегляд змінних, перехід між кадрами: `frame`, `info locals`). | Швидка діагностика. Ідеально для скриптів або коли програма "зависла". |
| **Механіка** | Пряме використання налагоджувача. | Bash-скрипт, який під капотом викликає `gdb -ex "bt" -ex "quit"`. |

### Висновок
В ході виконання завдання було доведено, що вивід ручного аналізу через GDB та автоматичного через `pstack` (або `gdb --batch`) є абсолютно ідентичним. Інструменти показують однаковий ланцюжок вкладеності викликів. Автоматичний метод зручний для швидкого отримання знімка завислого процесу, тоді як інтерактивний gdb дозволяє глибше дослідити стан пам'яті та змінні.

----------------------------------------------------------------------------------------
## Завдання 5
**Відомо, що при виклику процедур і поверненні з них процесор використовує стек.Чи можна в такій схемі обійтися без лічильника команд (IP), використовуючи замість нього вершину стека? Обґрунтуйте свою відповідь та наведіть приклади.**

### Коротка відповідь
Ні, обійтися без лічильника команд (IP / PC) неможливо. Хоча стек відіграє критичну роль у збереженні адрес повернення при виклику підпрограм, його вершина не може використовуватися як поточний вказівник на наступну інструкцію.

### Обгрунування
* Фундаментальне розділення коду та даних

Лічильник команд завжди вказує на адресу в сегменті коду (`text`), де інструкції розташовані послідовно. Стек знаходиться в окремому сегменті пам'яті та використовується для зберігання даних. 
Якби процесор брав адресу наступної команди з вершини стека, це порушило б логіку послідовного виконання програми: для виконання кожної наступної команди довелося б постійно завантажувати нові адреси у стек.

* «Захаращення» стека локальними змінними

Основна проблема полягає в тому, що стек є динамічною структурою для збереження даних під час роботи функції.
При виклику функції процесор дійсно кладе адресу повернення у стек. Проте всередині самої функції у стек починають додаватися локальні змінні. Якщо процесор спробує використати вершину стека як адресу наступної команди, він прочитає значення локальної змінної (наприклад, число `5`) як адресу пам'яті (наприклад, `0x00000005`). Це миттєво призведе до помилки доступу до пам'яті `Segmentation Fault` і краху програми.

### Приклад
У файлі **`test5.c`** наведено приклад того, як локальні дані перекривають адресу повернення на вершині стека.

**Як завжди скомпілюйте і запустіть програму**
```
gcc -Wall test5.c -o test5
```

```
./test5
```

І побачите ось такий результат:
<img width="825" height="164" alt="Знімок екрана 2026-02-15 122716" src="https://github.com/user-attachments/assets/bf28517d-6e4f-4b4b-aeb5-9dbfc9a59eb9" />
Якби вершина стека використовувалася замість лічильника команд (IP), процесор взяв би число `5` і спробував перейти за адресою `0x00000005`. 
 ### Що відбувається в програмі?
 
1. Виклик функції: процесор кладе адресу повернення у стек.
2. Створення локальної змінної. Компiлятор розміщує її на стеку. У цей момент вершиною стека стає значення `5`.
3. Перед виходом з функції компілятор очищає стек від `temp_var`. На вершині стека знову опиняється правильна адреса повернення.
4. Повернення: процесор бере адресу зі стека і продовжує роботу.

### Висновок
Стек - це механізм роботи з контекстом та збереження стану для повернення в минуле. Лічильник команд - це механізм керування потоком виконання, який дивиться в майбутнє і вказує на наступну інструкцію. Їхні функції принципово різні, і об'єднати їх в один механізм неможливо.

------------------------------------------------------------------------------------------------
## Завдання 6(індивідуальне Варіант 7)
**Створіть програму, що змінює права доступу до сегментів пам’яті (mprotect).**

Системний виклик `mprotect` дозволяє встановити захист на сегменти віртуальної пам'яті.

**В цій програмі спробуємо зробити** :
* Визначення розміру сторінки пам'яті операційної системи
* Виділення блоку пам'яті, який строго вирівняний по межі сторінки
* Запис початкових даних у цей блок (за замовчуванням доступний для читання та запису)
* Використання `mprotect` для обмеження прав доступу до режиму "тільки читання"
* Успішне зчитування даних з пам'ятіІ 
* Спроба запису в захищену ділянку, що призводить до апаратної помилки

### Вхідний код до цього завдання знаходиться в файлі `mprotect.c`

Скомпілюйте програму за допомогою стандартної команди
```
gcc -Wall mprotect.c -o mprotect
```
І запустіть скомпільований файл:
```
./mprotect
```
**Під час виконання програми, ви повинні побачити ось такий результат:**
<img width="886" height="256" alt="Знімок екрана 2026-02-15 131610" src="https://github.com/user-attachments/assets/1a7c6b83-bb3f-4c72-b6f6-b481ba960bce" />

Завершення програми з повідомленням `Segmentation fault` є очікуваною поведінкою. Воно доводить, що `mprotect успішно` заблокував доступ на запис до сторінки пам'яті, і операційна система аварійно зупинила процес за спробу порушення цих прав.

### Які системні функції були використані для написання програми?
* `sysconf(SC_PAGESIZE)` - отримання розміру сторінки пам'яті
* `posix_memalign()` - виділення вирівняної пам'яті
* `PROT_READ`- прапорець для  `mprotect`

### Поведінка програми 

| Етап виконання програми | Поточні права доступу | Виконувана дія | Реакція операційної системи |
| :--- | :--- | :--- | :--- |
| **1. Виділення пам'яті** | Читання та Запис| Запис рядка (`strcpy`) | **Успішно.** ОС дозволяє запис, дані зберігаються у буфері. |
| **2. Виклик mprotect** | Тільки читання | Зміна конфігурації сторінки | **Успішно.** ОС оновлює таблицю сторінок, знімаючи прапорець запису. |
| **3. Перевірка читання** | Тільки читання | Зчитування рядка (`printf`) | **Успішно.** Читання дозволено, дані виводяться на екран. |
| **4. Спроба запису** | Тільки читання | Запис рядка (`strcpy`) | **Блокування.** MMU виявляє порушення. Ядро надсилає `SIGSEGV`. |

### Висновки
Програма успішно демонструє механізми захисту віртуальної пам'яті. Системний виклик `mprotect` взаємодіє безпосередньо з ядром та апаратним модулем керування пам'яттю процесора, забезпечуючи надійний захист даних на найнижчому рівні. Це підтверджує, що контроль доступу здійснюється не лише правилами компілятора мови C, а й самою архітектурою системи.
Важливою умовою для коректної роботи цього механізму є строге вирівнювання адрес пам'яті. Оскільки операційна система керує пам'яттю блоками фіксованого розміру, тобто сторінками, зміна прав доступу можлива лише для цілих сторінок. Саме тому замість стандартного виділення пам'яті використовувалася спеціальна функція `posix_memalign`, яка гарантує, що початкова адреса сегмента точно збігається з межею сторінки.
Кінцевий етап роботи програми ілюструє суворий підхід операційної системи до безпеки. Коли процес намагається виконати несанкціоновану дію, наприклад, записати дані у сторінку з правами виключно на читання, система миттєво фіксує порушення доступу
## Кінець роботи. Дякую за прочитання!
