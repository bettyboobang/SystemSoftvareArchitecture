# Практична робота №2

В даній практичній роботі треба виконати 5 загальних завдань і одне по варіанту. Нижче описаний процес виконання кожного з них

## Завдання 1
**Напишіть програму для визначення моменту, коли time_t закінчиться.Дослідіть, які зміни відбуваються в залежності від 32- та 64-бітної архітектури. Дослідіть сегменти виконуваного файлу.**
### Попередні вимоги
Для успішної компіляції 32-бітного коду на 64-бітній операційній системі необхідно встановити пакет підтримки мультіліб:
```
sudo apt update
```
```
sudo apt install build-essential gcc-multilib
```
### Реалізація програми
Вхідний код програми знаходиться в файлі time_test.c. Як запустити програму буде описано трошки нижче.

**Програма виконує наступні дії**:

1. Визначає розмір time_t у байтах.

2. Обчислює максимально можливе значення для цього типу.

3.  Конвертує отримане число у дату формату UTC.

### Проблеми, що виникли під час виконання цього завдання

Під час розробки 64-бітної версії була виявлена критична помилка компіляції: `integer overflow in expression`.

При спробі обчислити максимальне значення для 64-бітного типу, використовувався наступний вираз:
`1 << 63`

У мові C літерал 1 за замовчуванням є знаковим цілим ака _signed int_. Зсув одиниці на 63-ю позицію (у знаковий біт) призводить до **невизначеної поведінки** або **переповнення**, оскільки число стає від'ємним.
#### Рішення проблеми
Код було модифіковано шляхом явного приведення одиниці до беззнакового типу (unsigned long long) перед виконанням побітового зсуву.

Фрагмент виправленого коду: 
```c
// Першочерговий невірний код: const long long max_time_val = ((long long)1 << (sizeof(time_t) * 8 - 1)) - 1;
const long long max_time_val = (long long)( ((unsigned long long)1 << (sizeof(time_t) * 8 - 1)) - 1 );
```
### Компіляція та запуск
Для аналізу і власне відповіді на питання з завдання потрібно скомпілювати дві версії програми.

#### 1. 32-бітна версія
-----------------------------------------
Для емуляції 32-бітного середовища використовується прапорець `-m32`

```
gcc -m32 time_test.c -o time32
```
Після успішної компіляції програми варто її запустити ось цією командою:
```
./time32
```
**Після запуску 32- бітної програми ви побачите ось такий результат**:

<img width="770" height="152" alt="Знімок екрана 2026-02-13 155639" src="https://github.com/user-attachments/assets/e575e138-e48b-40cd-82b7-d44d962c0b88" />

#### 2. 64- бітна версія
--------------------------
В цьому випадку скористаємося стандартною компіляцією до Убунту, бо нині всі комп'ютери мають 64-бітне середовище.
```

gcc -Wall time_test.c -o time64
```
Після успішної компіляції програми варто її запустити ось цією командою:
```
./time64
```
**Після запуску 64-бітної програми ви побачите ось такий результат**:

<img width="741" height="151" alt="Знімок екрана 2026-02-13 160557" src="https://github.com/user-attachments/assets/6175c930-4d64-41b4-985d-343dd327e068" />


Вже зараз можна побачити різницю в результатах, проаналізуємо їх за допомогою таблиці.
#### Таблиця виконання

| Характеристика | 32-бітна архітектура | 64-бітна архітектура (time64) |
| :--- | :---: | :---: |
| **Розмір time_t** | 4 байти (32 біти) | 8 байт (64 біти) |
| **Макс. Timestamp** | 2,147,483,647 | 9,223,372,036,854,775,807 |
| **Критична дата** | 2038-01-19 03:14:07 UTC | ~292 мільярди років у майбутньому |

### Аналіз сегментів(використання команди size)
`size` - це стандартна утиліта в Лінукс, яка показує структуру пам'яті програми. Вона не просто каже скільки файл займає місця на диску, а і розбиває її на логічні сегменти. Саме це нам і потрібно.

**Щоб проаналізувати нашу програму використаймо цю команду:**
```
size time32 time64
```
<img width="794" height="159" alt="Знімок екрана 2026-02-13 160037" src="https://github.com/user-attachments/assets/51b234db-ffd4-4d02-9a4b-70dad74c5ac3" />

На екрані побачимо ось такий результат

 #### Виглядає звісно гарно але _що це все означає_?

* **text(код)**

Код програми, що виконує процесор. Ця область доступна лише для читання і в 64-бітній версії відрізняється тим, що цей сегмент більший. Тому що інструкції та адреси пам'яті 64-бітного процесора займають більше місця.

* **data(дані)**

В цьому сегменті знаходяться глобальні змінні, яким ми дали початкове значення.

* **bss(block started by symbol)**

Тут знаходяться глобальні змінні без значення, тобто неініціалізовані.Цікавий факт, цей сегмент не займає місце у файлі на диску, але займає місце в оперативній пам'яті під час запуску програми.

* **dec(десятковий)**

Загальний розмір програми в байтах у звичній десятковій системі.

* **hex(шістнадцядковий)**

Те саме число тільки в шістнадцядковій системі числення.

### Висновок

Ми довели різницю архітектур, вона показана на таблиці:
| Файл | Сегмент text | Опис |
| :--- | :---: | :--- |
| **time32** | Менше | Використовує короткі адреси (4 байти). |
| **time64** | Більше | Використовує довгі адреси (8 байт), тому сама програма "товстіша". |

 А також підтверджено, що 32-бітні системи не здатні обробляти час після січня 2038 року. Після цієї дати значення часу стане від'ємним, що призведе до критичних помилок.

---------------------------------------------------------------------------------------
## Завдання 2
#### Розгляньте сегменти у виконуваному файлі.
##### 1. Скомпілюйте програму "hello world", запустіть ls -l для виконуваного файлу, щоб отримати його загальний розмір, і запустіть size, щоб отримати розміри сегментів всередині нього.
##### 2. Додайте оголошення глобального масиву із 1000 int, перекомпілюйте й повторіть вимірювання. Зверніть увагу на відмінності.
#### 3. Тепер додайте початкове значення в оголошення масиву (пам’ятайте, що C не змушує вас вказувати значення для кожного елемента масиву в ініціалізаторі). Це перемістить масив із сегмента BSS у сегмент даних. Повторіть вимірювання. Зверніть увагу на різницю.
##### 4. Тепер додайте оголошення великого масиву в локальну функцію. Оголосіть другий великий локальний масив з ініціалізатором. Повторіть вимірювання. Дані розташовуються всередині функцій, залишаючись у виконуваному файлі? Яка різниця, якщо масив ініціалізований чи ні?
##### 5. Які зміни відбуваються з розмірами файлів і сегментів, якщо ви компілюєте для налагодження? Для максимальної оптимізації?
#### Проаналізуйте результати, щоб переконатися, що:
##### *  сегмент даних зберігається у виконуваному файлі;
##### *  сегмент BSS не зберігається у виконуваному файлі (за винятком примітки щодо його вимог до розміру часу виконання);
##### *  текстовий сегмент більшою мірою піддається перевіркам оптимізації;
##### *  на розмір файлу a.out впливає компіляція для налагодження, але не сегменти.**

### Пункт 1

Створимо мінімальну програму для встановлення базових значень розмірів. Програма для цього завдання знаходиться в файлі test_helo.c. Всі зміни даного файлу можна переглянути в комітах.

**Створіть файл з усім відомою програмою Hello World**:
```c
#include <stdio.h>

int main() {
    printf("Hello World!!!\n");
    return 0;
}
```
_P.S. Для створення цього файлу в віртуальній машині скористайтесь командою_:
```
nano test_helo.c
```

### Для компіляції та вимірювань скористайтеся наступними командами
 ```
gcc -Wall test_helo.c -o hello
```
------------------------------------
```
ls -l hello
```
#### На екрані повинен з'явитись ось такий результат:

<img width="729" height="126" alt="Знімок екрана 2026-02-13 164908" src="https://github.com/user-attachments/assets/5e3da93f-cd45-45e7-9ae1-d6f59e9cc814" />
На зображенні можемо побачити що розмір файлу невеликий.




-------------------------------------------
```
size test
```
#### На екрані з'явиться такий результат:

<img width="811" height="242" alt="Знімок екрана 2026-02-13 164921" src="https://github.com/user-attachments/assets/a182302c-c778-4888-9d60-b51bffec55c6" />
На зображенні бачимо,що data i bss мають мінімальні значення
