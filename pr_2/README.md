# Практична робота №2

В даній практичній роботі треба виконати 5 загальних завдань і одне по варіанту. Нижче описаний процес виконання кожного з них

## Завдання 1
**Напишіть програму для визначення моменту, коли time_t закінчиться.Дослідіть, які зміни відбуваються в залежності від 32- та 64-бітної архітектури. Дослідіть сегменти виконуваного файлу.**
### Попередні вимоги
Для успішної компіляції 32-бітного коду на 64-бітній операційній системі необхідно встановити пакет підтримки мультіліб:
```
sudo apt update
```
```
sudo apt install build-essential gcc-multilib
```
### Реалізація програми
Вхідний код програми знаходиться в файлі time_test.c. Як запустити програму буде описано трошки нижче.

**Програма виконує наступні дії**:

1. Визначає розмір time_t у байтах.

2. Обчислює максимально можливе значення для цього типу.

3.  Конвертує отримане число у дату формату UTC.

### Проблеми, що виникли під час виконання цього завдання

Під час розробки 64-бітної версії була виявлена критична помилка компіляції: `integer overflow in expression`.

При спробі обчислити максимальне значення для 64-бітного типу, використовувався наступний вираз:
`1 << 63`

У мові C літерал 1 за замовчуванням є знаковим цілим ака _signed int_. Зсув одиниці на 63-ю позицію (у знаковий біт) призводить до **невизначеної поведінки** або **переповнення**, оскільки число стає від'ємним.
#### Рішення проблеми
Код було модифіковано шляхом явного приведення одиниці до беззнакового типу (unsigned long long) перед виконанням побітового зсуву.

Фрагмент виправленого коду: 
```c
// Першочерговий невірний код: const long long max_time_val = ((long long)1 << (sizeof(time_t) * 8 - 1)) - 1;
const long long max_time_val = (long long)( ((unsigned long long)1 << (sizeof(time_t) * 8 - 1)) - 1 );
```
### Компіляція та запуск
Для аналізу і власне відповіді на питання з завдання потрібно скомпілювати дві версії програми.

#### 1. 32-бітна версія
-----------------------------------------
Для емуляції 32-бітного середовища використовується прапорець `-m32`

```
gcc -m32 time_test.c -o time32
```
Після успішної компіляції програми варто її запустити ось цією командою:
```
./time32
```
**Після запуску 32- бітної програми ви побачите ось такий результат**:

<img width="770" height="152" alt="Знімок екрана 2026-02-13 155639" src="https://github.com/user-attachments/assets/e575e138-e48b-40cd-82b7-d44d962c0b88" />

#### 2. 64- бітна версія
--------------------------
В цьому випадку скористаємося стандартною компіляцією до Убунту, бо нині всі комп'ютери мають 64-бітне середовище.
```

gcc -Wall time_test.c -o time64
```
Після успішної компіляції програми варто її запустити ось цією командою:
```
./time64
```
**Після запуску 64-бітної програми ви побачите ось такий результат**:

<img width="741" height="151" alt="Знімок екрана 2026-02-13 160557" src="https://github.com/user-attachments/assets/6175c930-4d64-41b4-985d-343dd327e068" />


Вже зараз можна побачити різницю в результатах, проаналізуємо їх за допомогою таблиці.
#### Таблиця виконання

| Характеристика | 32-бітна архітектура | 64-бітна архітектура (time64) |
| :--- | :---: | :---: |
| **Розмір time_t** | 4 байти (32 біти) | 8 байт (64 біти) |
| **Макс. Timestamp** | 2,147,483,647 | 9,223,372,036,854,775,807 |
| **Критична дата** | 2038-01-19 03:14:07 UTC | ~292 мільярди років у майбутньому |

### Аналіз сегментів(використання команди size)
`size` - це стандартна утиліта в Лінукс, яка показує структуру пам'яті програми. Вона не просто каже скільки файл займає місця на диску, а і розбиває її на логічні сегменти. Саме це нам і потрібно.

**Щоб проаналізувати нашу програму використаймо цю команду:**
```
size time32 time64
```
<img width="794" height="159" alt="Знімок екрана 2026-02-13 160037" src="https://github.com/user-attachments/assets/51b234db-ffd4-4d02-9a4b-70dad74c5ac3" />

На екрані побачимо ось такий результат

 #### Виглядає звісно гарно але _що це все означає_?

* **text(код)**

Код програми, що виконує процесор. Ця область доступна лише для читання і в 64-бітній версії відрізняється тим, що цей сегмент більший. Тому що інструкції та адреси пам'яті 64-бітного процесора займають більше місця.

* **data(дані)**

В цьому сегменті знаходяться глобальні змінні, яким ми дали початкове значення.

* **bss(block started by symbol)**

Тут знаходяться глобальні змінні без значення, тобто неініціалізовані.Цікавий факт, цей сегмент не займає місце у файлі на диску, але займає місце в оперативній пам'яті під час запуску програми.

* **dec(десятковий)**

Загальний розмір програми в байтах у звичній десятковій системі.

* **hex(шістнадцядковий)**

Те саме число тільки в шістнадцядковій системі числення.

### Висновок

Ми довели різницю архітектур, вона показана на таблиці:
| Файл | Сегмент text | Опис |
| :--- | :---: | :--- |
| **time32** | Менше | Використовує короткі адреси (4 байти). |
| **time64** | Більше | Використовує довгі адреси (8 байт), тому сама програма "товстіша". |

 А також підтверджено, що 32-бітні системи не здатні обробляти час після січня 2038 року. Після цієї дати значення часу стане від'ємним, що призведе до критичних помилок.

---------------------------------------------------------------------------------------
## Завдання 2
#### Розгляньте сегменти у виконуваному файлі.
##### 1. Скомпілюйте програму "hello world", запустіть ls -l для виконуваного файлу, щоб отримати його загальний розмір, і запустіть size, щоб отримати розміри сегментів всередині нього.
##### 2. Додайте оголошення глобального масиву із 1000 int, перекомпілюйте й повторіть вимірювання. Зверніть увагу на відмінності.
#### 3. Тепер додайте початкове значення в оголошення масиву (пам’ятайте, що C не змушує вас вказувати значення для кожного елемента масиву в ініціалізаторі). Це перемістить масив із сегмента BSS у сегмент даних. Повторіть вимірювання. Зверніть увагу на різницю.
##### 4. Тепер додайте оголошення великого масиву в локальну функцію. Оголосіть другий великий локальний масив з ініціалізатором. Повторіть вимірювання. Дані розташовуються всередині функцій, залишаючись у виконуваному файлі? Яка різниця, якщо масив ініціалізований чи ні?
##### 5. Які зміни відбуваються з розмірами файлів і сегментів, якщо ви компілюєте для налагодження? Для максимальної оптимізації?
#### Проаналізуйте результати, щоб переконатися, що:
##### *  сегмент даних зберігається у виконуваному файлі;
##### *  сегмент BSS не зберігається у виконуваному файлі (за винятком примітки щодо його вимог до розміру часу виконання);
##### *  текстовий сегмент більшою мірою піддається перевіркам оптимізації;
##### *  на розмір файлу a.out впливає компіляція для налагодження, але не сегменти.**

### Пункт 1

Створимо мінімальну програму для встановлення базових значень розмірів. Програма для цього завдання знаходиться в файлі test_helo.c. Всі зміни даного файлу можна переглянути в комітах.

**Створіть файл з усім відомою програмою Hello World**:
```c
#include <stdio.h>

int main() {
    printf("Hello World!!!\n");
    return 0;
}
```
_P.S. Для створення цього файлу в віртуальній машині скористайтесь командою_:
```
nano test_helo.c
```

### Для компіляції та вимірювань скористайтеся наступними командами
 ```
gcc -Wall test_helo.c -o hello
```
------------------------------------
```
ls -l hello
```
#### На екрані повинен з'явитись ось такий результат:

<img width="729" height="126" alt="Знімок екрана 2026-02-13 164908" src="https://github.com/user-attachments/assets/ee46e8e2-6f0a-46cd-a246-4340c0ae171d" />

На зображенні можемо побачити що розмір файлу невеликий.




-------------------------------------------
```
size test
```
#### На екрані з'явиться такий результат:

<img width="711" height="142" alt="Знімок екрана 2026-02-13 164921" src="https://github.com/user-attachments/assets/e8702528-bd0d-4ce9-90df-69c0cc5c7164" />

На зображенні бачимо,що data i bss мають мінімальні значення

### Пункт 2

Додамо глобальний масив без початкових значень(неініціалізований)

**Перед int main додайте ось цей рядок:**
```c
int global_arr[1000];
```
### Скомпілюйте тим самим чином, що і в пункті один і виконайте команди вимірювань
------------------------------------
```
ls -l hello
```
#### На екрані повинен з'явитись ось такий результат:

<img width="715" height="128" alt="Знімок екрана 2026-02-13 165510" src="https://github.com/user-attachments/assets/8ef2edf1-0bb0-48e4-96a6-1f127c74f970" />


Бачимо, що файл на диску майже не змінився

-------------------------------------------
```
size test
```
#### На екрані з'явиться такий результат:


<img width="793" height="146" alt="Знімок екрана 2026-02-13 165525" src="https://github.com/user-attachments/assets/8f950467-9aa1-46d3-bc31-518113a4583b" />

 Бачимо, bss виріс приблизно на 4000 байт

#### Чому так?
BSS не зберігає нулі фізично. Він зберігає лише метадані (заголовок), який виділяє 4000 байт пам'яті при запуску і зануляє їх

### Пункт 3
Ініціалізуємо масив, щоб перемістити його з BSS у Data

**Змініть доданий в 2 пункті рядок на:**
```c
int global_arr[1000] = {1};
```
### Скомпілюйте тим самим чином, що і в пункті один і виконайте команди вимірювань
------------------------------------
```
ls -l hello
```
#### На екрані повинен з'явитись ось такий результат:

<img width="707" height="121" alt="Знімок екрана 2026-02-13 165709" src="https://github.com/user-attachments/assets/674c8c9d-1e9e-487c-a9e7-0bea8a7173bf" />

В результаті файл на диску збільшився на 4000 байт.

#### Чому так?
Оскільки значення відмінні від нуля, вони повинні зберігатися у бінарному файлі, щоб програма могла їх зчитати.

-------------------------------------------
```
size test
```
#### На екрані з'явиться такий результат:

<img width="701" height="143" alt="Знімок екрана 2026-02-13 165730" src="https://github.com/user-attachments/assets/8c5d9162-7656-44fc-b21c-b1cf6f6fbfd7" />


В результаті сегмент bss зменшився до мінімуму, а сегмент data виріс на 4000 байт.

### Пункт 4
Стек. Перемістимо масиви всередину функції.

**Замість рядка, що ми написали в 3 пункті, вставте ось цю функцію:**
```c
void func() {
    int local_arr[1000];          
    int local_arr_init[1000] = {1};
}
```
### Скомпілюйте тим самим чином, що і в пункті один і виконайте команди вимірювань

_P.S. Через те що ми компілюємо через `-Wall` і просимо компілятор повідомляти про все, що його не влаштовує він може сваритися. Але нашому дослідженню це не завадить_

------------------------------------
```
ls -l hello
```
#### На екрані повинен з'явитись ось такий результат:

<img width="724" height="124" alt="Знімок екрана 2026-02-13 171206" src="https://github.com/user-attachments/assets/fd612118-f469-4fb2-817d-21c46b2cbda8" />

-------------------------------------------
```
size test
```
#### На екрані з'явиться такий результат:


<img width="707" height="140" alt="Знімок екрана 2026-02-13 171218" src="https://github.com/user-attachments/assets/fdfad11b-37c0-4c79-8842-8933d5b2658b" />

bss i data повертаються до розмірів як в Пункті 1

#### Чому так?
Локальні змінні зберігаються у стеку. Стек створюється динамічно під час виконання програми в оперативній пам'яті. Він не є статичним сегментом у виконуваному файлі

### Пункт 5
Використовуємо код із пункту 3, але додамо використання змінної, щоб оптимізатор не видалив її

**Для виконання цього пункту команда компіляції змінюється і виглядає подібним чином:**
```
gcc -g test_helo.c -o test_debug
```
------------------------------------
```
ls -l hello
```
#### На екрані повинен з'явитись ось такий результат:

<img width="762" height="126" alt="Знімок екрана 2026-02-13 171634" src="https://github.com/user-attachments/assets/e84c46b3-e34b-469e-9224-54787c221733" />


В результаті файл на диску значно більший (зберігає таблиці символів, імена змінних, прив'язку до рядків коду).


-------------------------------------------
```
size test
```
#### На екрані з'явиться такий результат:
<img width="748" height="148" alt="Знімок екрана 2026-02-13 171654" src="https://github.com/user-attachments/assets/55e1fa92-3a0b-456e-ab4d-93e7a9c41c88" />

Cегменти залишились майже без змін. Налагоджувальна інформація не завантажується в пам'ять як частина виконуваних сегментів.

**Для максимальної оптимізації код ще можна скомпілювати ось таким чином:**
```
gcc -o3 test_helo.c -o test_opt
```
------------------------------------
```
ls -l hello
```
#### На екрані повинен з'явитись ось такий результат:

<img width="742" height="127" alt="Знімок екрана 2026-02-13 171848" src="https://github.com/user-attachments/assets/24eadef5-1d5c-4bef-b8e6-19e8f261825a" />


-------------------------------------------
```
size test
```
#### На екрані з'явиться такий результат:
<img width="706" height="140" alt="Знімок екрана 2026-02-13 171905" src="https://github.com/user-attachments/assets/9b816116-e63b-4337-9b60-885478a01292" />

Сегмент text може зменшитися (видалення зайвого) або збільшитися (розгортання циклів). Сегмент data залишиться на місці, бо ми використали масив у printf. Якби ми не використали масив, розумний оптимізатор видалив би його повністю.

### Для аналізу результатів та фінального порівняння представлена таблиця:

| Зміна в коді | сегмент Data | сегмент BSS | Розмір файлу на диску | Де живуть дані? |
| :--- | :---: | :---: | :---: | :--- |
| **Hello World** | ~500 B | ~10 B | Малий | — |
| **Глобальний `int a[1000]`** | Без змін | +4000 B | Без змін | RAM (виділяється при старті) |
| **Глобальний `int a[1000]={1}`** | +4000 B | Без змін | +4000 B | Всередині файлу EXE |
| **Локальні масиви** | Без змін | Без змін | Без змін | Стек  |
| **Debug (-g)** | Без змін | Без змін | Дуже великий | Секції Debug info |

### Висновки
В цьому завданні ми наочно продемонстрували, що спосіб оголошення та ініціалізації змінних визначає їхнє розміщення у пам'яті та вплив на розмір виконуваного файлу. Зокрема, ініціалізовані глобальні дані зберігаються у сегменті data і збільшують фізичний розмір файлу на диску, тоді як неініціалізовані потрапляють у сегмент bss, займаючи місце лише в оперативній пам'яті під час виконання програми. Локальні змінні взагалі не впливають на статичні сегменти, оскільки розміщуються на стеку динамічно, а додавання налагоджувальної інформації суттєво збільшує файл за рахунок метаданих, не змінюючи при цьому розмір завантажуваних у пам'ять частин коду та даних.
